#!/usr/bin/env python3
# sentinel_smart_lock_gui_motor_soft.py â€” GUI-only motor buttons access

import sys, os, time, datetime, sqlite3, traceback
from threading import Thread, Lock, Event

import cv2, dlib, numpy as np, pandas as pd
import tkinter as tk
from PIL import Image, ImageTk

frame = None
camera_cap = None

# ---------------- CONFIG ----------------
TOGGLE_COOLDOWN = 12
CAM_WIDTH = 640
CAM_HEIGHT = 480
CAM_TRY_INDICES = list(range(0, 5))
MASTER_TAG = "769839607204"
MASTER_NAME = "Universal"

# ---------------- STATE ----------------
csv_mutex = Lock()
lock_mutex = Lock()
frame_mutex = Lock()
lock_open = False
current_user = None
user_last_toggle = {}
active_rfid = {"text": "None", "last_seen": 0}
active_face = {"text": "None", "last_seen": 0}

# ---------------- Logging ----------------
def log_sentence(method, identifier, action):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
    sentence = f"{ts}: {action} by {method} user {identifier}."
    with csv_mutex:
        with open("Logs.csv", "a") as f:
            f.write(sentence + "\n")
    print(sentence)

# ---------------- Lock Control ----------------
def open_lock(method, identifier):
    global lock_open, current_user
    now = time.time()
    last = user_last_toggle.get(identifier, 0)
    if now - last < TOGGLE_COOLDOWN: return False
    with lock_mutex:
        if not lock_open:
            lock_open = True
            current_user = identifier
            user_last_toggle[identifier] = now
            log_sentence(method, identifier, "Lock opened")
            return True
    return False

def close_lock(method, identifier):
    global lock_open, current_user
    now = time.time()
    last = user_last_toggle.get(identifier, 0)
    if now - last < TOGGLE_COOLDOWN: return False
    with lock_mutex:
        if lock_open and current_user == identifier:
            lock_open = False
            user_last_toggle[identifier] = now
            log_sentence(method, identifier, "Lock closed")
            current_user = None
            return True
    return False

# ---------------- RFID ----------------
reader = None
try:
    from mfrc522 import SimpleMFRC522
    reader = SimpleMFRC522()
except Exception:
    print("âš  RFID not available")

def handle_rfid_detection(tag_id):
    tag_str = str(tag_id)
    global current_user
    if tag_str == MASTER_TAG:
        identifier = MASTER_NAME
        if not lock_open: open_lock("RFID", identifier)
        else: close_lock("RFID", identifier)
        active_rfid["text"] = identifier
        active_rfid["last_seen"] = time.time()
        return

    try:
        conn = sqlite3.connect("rfid_data.db")
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM rfid_users WHERE tag_id=?", (tag_str,))
        res = cursor.fetchone()
        conn.close()
    except: res = None

    if not res:
        active_rfid["text"] = f"Unknown({tag_str})"
        active_rfid["last_seen"] = time.time()
        return

    name = res[0]
    identifier = f"{name}({tag_str})"
    active_rfid["text"] = identifier
    active_rfid["last_seen"] = time.time()
    if not lock_open: open_lock("RFID", identifier)
    elif current_user == identifier: close_lock("RFID", identifier)

def rfid_thread_loop(stop_event: Event):
    if reader is None: return
    while not stop_event.is_set():
        try:
            uid, _ = reader.read_no_block()
            if uid: handle_rfid_detection(uid)
        except Exception: traceback.print_exc()
        time.sleep(0.25)

# ---------------- Face ----------------
detector = dlib.get_frontal_face_detector()
predictor, face_model = None, None
try:
    predictor = dlib.shape_predictor("data/data_dlib/shape_predictor_68_face_landmarks.dat")
    face_model = dlib.face_recognition_model_v1("data/data_dlib/dlib_face_recognition_resnet_model_v1.dat")
except: print("Face model not loaded")

known_features, known_names = [], []
if os.path.exists("data/features_all.csv"):
    df = pd.read_csv("data/features_all.csv", header=None)
    for i in range(df.shape[0]):
        known_names.append(df.iloc[i,0])
        known_features.append([float(df.iloc[i,j]) for j in range(1,129)])

def handle_face_detection(name):
    now = time.time()
    active_face["text"] = name
    active_face["last_seen"] = now
    if name != "Unknown":
        if not lock_open: open_lock("FACE", name)
        elif current_user == name: close_lock("FACE", name)

def face_thread_loop(stop_event: Event):
    global frame
    while not stop_event.is_set():
        if predictor is None or face_model is None or not known_features:
            time.sleep(0.5)
            continue
        with frame_mutex:
            local = None if frame is None else frame.copy()
        if local is None:
            time.sleep(0.05)
            continue
        try:
            bgr = cv2.cvtColor(local, cv2.COLOR_RGB2BGR)
            faces = detector(bgr, 0)
            for f in faces:
                shape = predictor(bgr,f)
                feat = np.array(face_model.compute_face_descriptor(bgr,shape))
                distances = [np.linalg.norm(feat-np.array(x)) for x in known_features]
                name = known_names[int(np.argmin(distances))] if distances and min(distances)<0.6 else "Unknown"
                handle_face_detection(name)
                break
            else: active_face["text"]="None"
        except: traceback.print_exc()
        time.sleep(0.12)

# ---------------- Camera ----------------
def camera_init_and_stream(stop_event: Event):
    global camera_cap, frame
    import cv2
    for idx in range(0,5):
        try:
            cap = cv2.VideoCapture(idx, cv2.CAP_V4L2)
            if cap.isOpened():
                cap.set(cv2.CAP_PROP_FRAME_WIDTH,CAM_WIDTH)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT,CAM_HEIGHT)
                camera_cap = cap
                break
            else: cap.release()
        except: continue
    if camera_cap is None: return
    while not stop_event.is_set():
        ret,img = camera_cap.read()
        if ret:
            rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            with frame_mutex: frame = rgb
        time.sleep(0.03)
    if camera_cap: camera_cap.release(); camera_cap=None

# ---------------- GUI ----------------
class SentinelGUI:
    def __init__(self, root, stop_event: Event):
        self.root=root
        self.stop_event=stop_event
        root.title("Sentinel Smart Lock")
        root.configure(bg="#071428")
        root.geometry("900x600")

        # Header
        self.header=tk.Label(root,text="ðŸ›¡ Sentinel Smart Lock", font=("Helvetica",28,"bold"), bg="#071428", fg="#7BE0E0")
        self.header.pack(pady=6)
        self.time_label=tk.Label(root,text="", font=("Helvetica",16), bg="#071428", fg="#CFEFF0")
        self.time_label.pack()

        # Camera
        self.cam_frame=tk.Frame(root, bg="#07202A", bd=4, relief="ridge")
        self.cam_frame.pack(pady=6)
        self.camera_label=tk.Label(self.cam_frame)
        self.camera_label.pack()

        # Status
        self.status_frame=tk.Frame(root, bg="#071428")
        self.status_frame.pack(pady=6)
        self.rfid_label=tk.Label(self.status_frame, text="RFID: None", font=("Helvetica",16), bg="#071428", fg="#A3FFD9")
        self.rfid_label.pack()
        self.face_label=tk.Label(self.status_frame, text="Face: None", font=("Helvetica",16), bg="#071428", fg="#A3FFD9")
        self.face_label.pack()
        self.lock_label=tk.Label(self.status_frame, text="Lock: Closed", font=("Helvetica",16), bg="#071428", fg="#FFD27A")
        self.lock_label.pack()

        # Motor Control (GUI-only)
        self.motor_frame=tk.Frame(root, bg="#1E1E2F", bd=4, relief="ridge")
        self.motor_frame.pack(pady=10)
        self.motor_label=tk.Label(self.motor_frame,text="Machine Control (GUI Only)", font=("Helvetica",18,"bold"), bg="#1E1E2F", fg="#FFD27A")
        self.motor_label.pack(pady=6)
        self.btn_on=tk.Button(self.motor_frame,text="Machine ON", font=("Helvetica",16,"bold"), bg="#13A88E", fg="white", padx=20, pady=6, command=self.machine_on, state="disabled")
        self.btn_on.pack(side="left", padx=20)
        self.btn_off=tk.Button(self.motor_frame,text="Machine OFF", font=("Helvetica",16,"bold"), bg="#E03C31", fg="white", padx=20, pady=6, command=self.machine_off, state="disabled")
        self.btn_off.pack(side="right", padx=20)

        self.footer=tk.Label(root,text="Developed by Vadeendra Karanam [CSE-IoT 2026 Batch]", font=("Helvetica",12), bg="#071428", fg="#9FB9BE")
        self.footer.pack(side="bottom", pady=6)

        self.update_clock()
        self.update_frame()
        self.update_status()
        root.protocol("WM_DELETE_WINDOW", self.on_close)

    def update_clock(self):
        self.time_label.config(text=datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p"))
        if not self.stop_event.is_set(): self.root.after(1000,self.update_clock)

    def update_frame(self):
        with frame_mutex: local = None if frame is None else frame.copy()
        if local is not None:
            try:
                img = Image.fromarray(local).resize((320,240))
                imgtk = ImageTk.PhotoImage(img)
                self.camera_label.imgtk = imgtk
                self.camera_label.configure(image=imgtk)
            except: traceback.print_exc()
        if not self.stop_event.is_set(): self.root.after(30,self.update_frame)

    def update_status(self):
        self.rfid_label.config(text=f"RFID: {active_rfid['text']}")
        self.face_label.config(text=f"Face: {active_face['text']}")
        lock_text = f"Lock: {'Opened by '+current_user if lock_open else 'Closed'}"
        self.lock_label.config(text=lock_text)
        # Enable buttons only if known user has lock open
        if lock_open and current_user is not None:
            self.btn_on.config(state="normal")
            self.btn_off.config(state="normal")
        else:
            self.btn_on.config(state="disabled")
            self.btn_off.config(state="disabled")
        if not self.stop_event.is_set(): self.root.after(500,self.update_status)

    def machine_on(self):
        log_sentence("MACHINE", current_user, "GUI ON clicked")

    def machine_off(self):
        log_sentence("MACHINE", current_user, "GUI OFF clicked")

    def on_close(self):
        self.stop_event.set()
        if camera_cap: camera_cap.release()
        self.root.destroy()
        os._exit(0)

# ---------------- START ----------------
def start_all():
    stop_event = Event()
    Thread(target=camera_init_and_stream, args=(stop_event,), daemon=True).start()
    Thread(target=face_thread_loop, args=(stop_event,), daemon=True).start()
    if reader: Thread(target=rfid_thread_loop, args=(stop_event,), daemon=True).start()
    root = tk.Tk()
    SentinelGUI(root, stop_event)
    root.mainloop()
    stop_event.set()

if __name__=="__main__":
    start_all()
